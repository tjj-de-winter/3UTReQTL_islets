### Description ###

# Compute eQTLs using the R package SCeQTL for a given cell type
# A variant is tested exclusively in conjunction with the gene in which it is located (i.e. cis-eQTL).

### Import packages ###
import sys, os
import pandas as pd
from collections import Counter
import scanpy as sc
import numpy as np
from pandarallel import pandarallel
from contextlib import contextmanager
import threading
import _thread
# packages to run R:
import rpy2
import rpy2.robjects as ro
from rpy2.robjects.packages import importr
from rpy2.robjects import pandas2ri
import argparse

from rpy2.robjects.conversion import localconverter

SCeQTL = importr("SCeQTL")
base = importr('base')
utils = importr('utils')
r = ro.r

### Input variables ###

parser = argparse.ArgumentParser(description='Compute eQTLs using the R package SCeQTL for a given cell type')
parser.add_argument('--geno', help="CSV file with variant as rows, sample as cols and integers as genotype as generated by variant_matrix.py")
parser.add_argument('--genes', help="DESeq normalized gene count matrix, rows=genes, cols=cells as generated by DEseq_normalization.py")
parser.add_argument('--h5ad',help='a scanpy generated h5ad object with cell type annotation')
parser.add_argument('--cell_type',help='Cell type name to use for eQTL calculation')
parser.add_argument('--group',default='non-grouped',help='Optional: subgroup or subcondition to use for eQTL calculation')
parser.add_argument('--sampleID_header',help='Sample ID column, note: SampleIDs have to match with sampleIDs in the variant matrix')
parser.add_argument('--group_header', default="Group",help='Name of the column in adata.obs that contains group or condition information')
parser.add_argument('--celltype_header', default="Cell_type",help='Name of the column in adata.obs that contains cell type information')
parser.add_argument('--cell_and_group', action="store_true",help='Enable to compute eQTLs for each cell type and group seperately, if not used only cell type is used')
parser.add_argument('--outprefix', help='outprefix')
parser.add_argument('--outdir', default='.',help='output path')
args = parser.parse_args()

SampleGenoMatrix = args.geno 
GeneExpMatrix = args.genes
h5ad = args.h5ad
cell_type = args.cell_type
group = args.group
group_col = args.group_header 
celltype_col = args.celltype_header
sampleID_col = args.sampleID_header
cell_and_group = args.cell_and_group
outprefix = args.outprefix
outdir = args.outdir


### Parameters ###
threads = 8 # adjust if needed
n_alternative_geno = 2 # number of samples where an alternative genotype need to be present in order to calculate eQTL behaviour

### Functions ###

# timer to stop R function from running infinite in certain situations

class TimeoutException(Exception):
    def __init__(self, msg=''):
        self.msg = msg

@contextmanager
def time_limit(seconds, msg=''):
    timer = threading.Timer(seconds, lambda: _thread.interrupt_main())
    timer.start()
    try:
        yield
    except KeyboardInterrupt:
        raise TimeoutException("Timed out for operation {}".format(msg))
    finally:
        # if the action ends in specified time, timer is canceled
        timer.cancel()

# prevent output from printing
class NoStdStreams(object):
    def __init__(self,stdout = None, stderr = None):
        self.devnull = open(os.devnull,'w')
        self._stdout = stdout or self.devnull or sys.stdout
        self._stderr = stderr or self.devnull or sys.stderr

    def __enter__(self):
        self.old_stdout, self.old_stderr = sys.stdout, sys.stderr
        self.old_stdout.flush(); self.old_stderr.flush()
        sys.stdout, sys.stderr = self._stdout, self._stderr

    def __exit__(self, exc_type, exc_value, traceback):
        self._stdout.flush(); self._stderr.flush()
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr
        self.devnull.close()

def cell_sample_dict(adata, sampleID_col):
    '''extract a dictionary containing cell ID and sample ID'''
    df = adata.obs.loc[:,[sampleID_col]]

    return {cell: sample for cell, sample in zip(df.index, df[sampleID_col])}

def Matrices4SCeQTL(variant, cells, SGM, genex, samples, sample_cell_dict, n_alternative_geno=n_alternative_geno):
    '''Check if the genotype of the variant various between the samples to test and if the gene is expressed.
        If that is the case, make the gene expression and genotype sub dataframes with the gene and variant to test'''
    gene = '>'.join([variant.rsplit('_')[2],variant.rsplit(':')[0]])

    # check if an alternative genotype is present in at least x amount of samples, otherwise do not calculate
    sample_gt = [SGM.loc[variant,sample] for sample in samples]

    if '.' in sample_gt:
        sample_gt = list(filter(lambda a: a != '.', sample_gt))

    counter = Counter(sample_gt)
    value_list = [counter[key] for key in counter]

    if not any(count >= n_alternative_geno for count in value_list[1:]):
        return False, False

    # Get genotypes per cell and remove cells without a called genotype (i.e. '.')
    SGM_ct = pd.DataFrame(index=[variant], columns=cells)

    SGM_ct.loc[variant,:] = [SGM.loc[variant,sample_cell_dict[cell].upper()] for cell in cells]
    SGM_ct = pd.DataFrame(SGM_ct.T[SGM_ct.T[variant]!= '.']).T
    ct_gt = SGM_ct.loc[variant,:]
    SGM_ct.loc[variant,:] = [list(sorted(set(ct_gt))).index(i) for i in ct_gt]

    # generate count matrix with selected cells and check if gene is expressed
    cells = SGM_ct.columns
    try:
        genex_ct = pd.DataFrame(genex.loc[gene, cells]).T
    except:
        return False, False
    
    if len(genex_ct.loc[gene]) == 0:
        return False, False

    if np.sum(genex_ct.loc[gene]) != 0: 
        return SGM_ct, genex_ct
    else:
        return False, False

def eQTL_calculation(variant, cell_type, group, SGM, genex, cells, samples, n_alternative_geno=n_alternative_geno):
    '''Given a gene and genotype matrix, compute eQTL association. 
    This code takes a single variant and a single gene, so it can be used with parallel processing'''

    gene = '>'.join([variant.rsplit('_')[2],variant.rsplit(':')[0]])
    
    faulty_data = [gene, variant, "None", '_'.join([cell_type,group])] # output in case SCeQTL does not compute an association
    SGM_ct, genex_ct = Matrices4SCeQTL(variant, cells, SGM, genex, samples, sample_cell_dict,n_alternative_geno=n_alternative_geno)
    if type(SGM_ct) == bool:
        return faulty_data

    # import the matrices into SCeQTL
    SGM_ct = SGM_ct.loc[:,genex_ct.columns]
    with localconverter(ro.default_converter + pandas2ri.converter):
        gene = ro.conversion.py2rpy(genex_ct)
    with localconverter(ro.default_converter + pandas2ri.converter):
        var = ro.conversion.py2rpy(SGM_ct)
    var = base.as_matrix(var)
    with time_limit(180,'eQTL'):
        try:
            with NoStdStreams(): # do not print the R console output    
                with time_limit(240,'eQTL'): #4 minutes
                    result = SCeQTL.cal_pvalue(gene, var, remove_outlier=True, EM=True, dist='negbin',thread=1, type=2)
        #try:
        except:
            return faulty_data
    
    with localconverter(ro.default_converter + pandas2ri.converter):
        result_pd = ro.conversion.rpy2py(result)
    if result_pd.loc['1', 'pvalue'] <= 0:
        result_pd.loc['1', 'pvalue'] = np.nan
    if len(list(result_pd.iloc[0,:])) == 3: 
        data = list(result_pd.iloc[0,:])+['_'.join([cell_type,group])]
        return data
    else:
        return faulty_data

### Code ###

if not os.path.exists(outdir):
        os.makedirs(outdir)

# load the data

adata = sc.read_h5ad(h5ad)
genex = pd.read_csv(GeneExpMatrix, sep=",", index_col=0)
genex.columns = [col.replace('.','-') for col in genex.columns] 
SGM = pd.read_csv(SampleGenoMatrix, sep=",", index_col=0)

if cell_and_group:
    cells = adata[(adata.obs[celltype_col] == cell_type) & (adata.obs[group_col] == group)].obs.index
else:
    cells = adata[(adata.obs[celltype_col] == cell_type)].obs.index

# get sample ID using the cell ID to make a genotype subset matrix
sample_cell_dict = cell_sample_dict(adata, sampleID_col)
samples = list(set([sample_cell_dict[cell] for cell in cells]))
samples = [s.upper() for s in samples]
SGM.columns = [c.upper() for c in SGM.columns]
SGM = SGM.loc[:,samples]

del adata

#remove variants where all genotypes are equal or not detected in the sample subset
df = pd.DataFrame(SGM.sum(axis=1))
df['gts'] = df[0].apply(lambda x: x.replace('.',''))
df = df[df['gts'] != '']
df['equal'] = df['gts'].apply(lambda x: len(set(x)) == 1)
df = df[df['equal'] == False]
SGM = SGM.loc[df.index,:].copy()
# SGM = SGM[~df['equal']].copy()
del df

# Select the variants to test
genes = [g.rsplit('>')[0] for g in genex.index]
variant_list = [v for v in SGM.index if v.rsplit('_')[2] in genes]
variant_list = list(SGM.index)
df_eQTLdata = pd.DataFrame(index=range(len(variant_list)))
df_eQTLdata['variant'] = variant_list

# compute eQTLs
pandarallel.initialize(progress_bar=True, nb_workers=threads, use_memory_fs=False)
df_eQTLdata['data'] = df_eQTLdata['variant'].parallel_apply(lambda variant: eQTL_calculation(variant, cell_type, group, SGM, genex, cells, samples, n_alternative_geno=n_alternative_geno)) 

# export the data to CSV
eQTL_dict = {i: df_eQTLdata.loc[i,'data'] for i in df_eQTLdata.index}
eQTL_df = pd.DataFrame(eQTL_dict).T
eQTL_df = eQTL_df.dropna(how='all')
outfile = '_'.join([outprefix,cell_type, group, 'eQTL.csv'])
outfile = f'{outdir.rstrip("/")}/{outfile}'
eQTL_df.to_csv(outfile, mode='w', index=False, header=False)	

sys.exit()








